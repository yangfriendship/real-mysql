# Real Mysql Chapter11

- 데이터 베이스나 테이블의 구조를 변경하기 위한 문장을 DDL (Data Definition Language)
- 테이블의 데이터를 조작하기 위한 문장을 DML(Data Manipulation Language)

### 11.1.2 영문 대소문자 구분

- MySql 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.
    - 윈도우 계열은 대소문자를 구분하지 않지만 유닉스 계열은 대소문자를 구분

### 11.1.3 MySql 예약어

- 예약어로 지정된 단어를 사용하려면 역따옴표(`) 를 사용해서 만들어야한다.

### 11.3.1 리터럴 표기법 문자열

- Sql 표준에서 문자열은 항상 홑따옴표(') 를 사용하지만 MySql 에서는 쌍따옴표도 사용할 수 있다.
- 그래서 [예약어로 지정된 단어](#1113-mysql-)를 사용할 때는 쌍따옴표가 아니라 역따옴표를 사용해서 감싸주어야 한다.

### 11.3.1.2 숫자

- 따옴표가 없는 숫자는 숫자값으로 인식한다.
- 문자열 형태로 따옴표를 사용하더라도 비교 대상이 숫자 값이거나 숫자 타입의 컬럼이면 자동으로 문자열 값을 숫자 값으로 변환해준다.
- MySql 은 숫자 타입과 문자열 타입 간의 비교에서 숫자 타입을 우선시하므로 문자열 값을 숫자 값으로 변환한 후 비교를 수행한다.
- 만약 인덱스의 값이 string 이고 비교 값이 숫자라면 MySql 은 인덱스(string)을 숫자 형태로 변형하여 비교를 진행하므로        
  index 를 사용할 수 없다.(형이 변형된 인덱스 컬럼의 값은 인덱스의 혜택을 받을 수 없다.)

### 11.3.1.3 날짜

- 다른 DBMS 에서 날짜 타입을 비교하거나 삽입하려면 문자열을 DATE 타입으로 변환하는 코드가 필요하지만 MySql 에서는 정해진 형태    
  의 날짜 포맷으로 표기하면 자동으로 date datetime 값으로 변환하기 때문에 str_to_date() 같은 함수를 사용하지 않아도 된다.

### 11.3.1.4 불리언 (boolean)

- bool, boolean 이라는 타입이 있지만 사실 이것은 tinyint 타입에 대한 동의어일 뿐이다.

### 11.3.2.1

- <=> null safe 연산자, equals + is null 기능이 함께 있다.
- null 을 하나의 값이라고 생각하며 비교하는 방법

```
mysql> select 1 <=>1, null <=> null, 1 <=> null;
+--------+---------------+------------+
| 1 <=>1 | null <=> null | 1 <=> null |
+--------+---------------+------------+
|      1 |             1 |          0 |
+--------+---------------+------------+
1 row in set (0.00 sec)
```

### 11.3.2.2 부정 비교

- 일반적으로 <> 를 많이 사용한다. != 도 사용 가능하다.
- 혼잡하니까 둘 중 하나면 사용하자. 나라면 !=

```
mysql> select 1 <> 2, 1 <> 1;
+--------+--------+
| 1 <> 2 | 1 <> 1 |
+--------+--------+
|      1 |      0 |
+--------+--------+
1 row in set (0.00 sec)
```

### 11.3.2.3 NOT 연산자(!)

- 프로그래밍 언어의 ! 과 같은 역할

```
mysql> select !1, !FALSE, NOT 1, NOT 0, NOT(1=1);
+----+--------+-------+-------+----------+
| !1 | !FALSE | NOT 1 | NOT 0 | NOT(1=1) |
+----+--------+-------+-------+----------+
|  0 |      1 |     0 |     1 |        0 |
+----+--------+-------+-------+----------+
1 row in set, 2 warnings (0.00 sec)
```

### 11.3.2.4 AND 와 OR 연산자

- MySql 에서는 || && 연산자를 모두 사용할 수 있다.(오라클에서는 || 는 문자열 연결)
- 괄호가 없는 AND OR 조합의 연산에서는 AND 연산이 항상 우선적으로 실행된다.

```
mysql> select TRUE OR FALSE AND FALSE;
+-------------------------+
| TRUE OR FALSE AND FALSE |
+-------------------------+
|                       1 |
+-------------------------+
1 row in set (0.00 sec)
```

### 11.3.2.6 regexp 연산자

- 문자열 값이 어떤 패턴을 만족하는지 확인하는 연산자, RLIKE 는 똑같은 비교연산을 수행하는 연산자다.
- regexp 연산자를 문자열 컬럼 비교에 사용할 때 regexp 조건의 비교는 인덱스 레인지 스캔을 사용할 수 없다.
- where 조건절에 regexp 연산자를 사용한 조건을 단독으로 사용하는 것은 성능상 좋지 않다.
- 데이터 조회 범위를 줄일 수 있는 조건과 함께 사용하길 권장한다.

```
mysql> select 'abc' regexp '^[x-z]', 'abc' regexp '^[a]';
+-----------------------+---------------------+
| 'abc' regexp '^[x-z]' | 'abc' regexp '^[a]' |
+-----------------------+---------------------+
|                     0 |                   1 |
+-----------------------+---------------------+
1 row in set (0.00 sec)
```

### 11.3.2.7 like 연산자

- 단순 문자열 패턴 비교 연산자. 어떤 상수 문자열이 있는지 없는지 정도를 판단
- 인덱스를 이용해 처리할 수 있다.
- %: 0개 또는 1 개 이상의 모든 문자에 일치
- _: 정확히 1개의 문자에 일치
- 와일드 카드가 검색어의 뒤쪽에 있다면 인덱스 레인지 스캔을 사용할 수 있지만, 검색어의 앞쪽에 있다면 인덱스 레인지 스캔을 사용할    
  수 없다. (Left-most)

### 11.3.2.5 나누기와 나머지 연산자

- /, div: 몫
- mod(), mod, %: 나머지

```
mysql> select 29 / 9, 29 div 9, mod(29,9), 29 mod 9, 29 % 9;
+--------+----------+-----------+----------+--------+
| 29 / 9 | 29 div 9 | mod(29,9) | 29 mod 9 | 29 % 9 |
+--------+----------+-----------+----------+--------+
| 3.2222 |        3 |         2 |        2 |      2 |
+--------+----------+-----------+----------+--------+
1 row in set (0.00 sec)
```

### 11.3.2.8 between 연산자

- 크거나 같다 와 작거나 같다 라는 두 개의 연산자를 합친 연산자

### 11.3.2.9 IN 연산자

- 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자.
- 범위 검색이 아니라 여러 번의 동등 비교로 실행하기 때문에 일반적으로 빠르게 실행된다.
- 두 가지 형태로 구분할 수 있다.
    - 상수가 사용된 경우 - IN(?, ?, ?)
    - 서브쿼리가 사용된 경우 - IN(select ... from...)
- NOT IN 의 실행 계획은 인덱스 풀 스캔으로 표시되는데, 동등이 아닌 부정형 비교여서 인덱스를 이용해 처리 범위를 줄이는 조건으로    
  사용할 수 없기 때문이다.

### 11.3.3.1 null 값 비교 및 대체(IFNULL, ISNULL)

- 컬럼이나 표현식의 값이 null 인지 비교하고, null 이면 다른 값으로 대체헤는 용도

```
mysql> select ifnull(null,1), ifnull(0,1), isnull(1/0), isnull(null);
+----------------+-------------+-------------+--------------+
| ifnull(null,1) | ifnull(0,1) | isnull(1/0) | isnull(null) |
+----------------+-------------+-------------+--------------+
|              1 |           0 |           1 |            1 |
+----------------+-------------+-------------+--------------+
1 row in set, 1 warning (0.00 sec)
```

### 11.3.3.2 현재 시각 조회(now, sysdate)

```
mysql> select now(), sleep(2), now(), sysdate(), sleep(2), sysdate();
+---------------------+----------+---------------------+---------------------+----------+---------------------+
| now()               | sleep(2) | now()               | sysdate()           | sleep(2) | sysdate()           |
+---------------------+----------+---------------------+---------------------+----------+---------------------+
| 2022-04-14 22:40:05 |        0 | 2022-04-14 22:40:05 | 2022-04-14 22:40:07 |        0 | 2022-04-14 22:40:09 |
+---------------------+----------+---------------------+---------------------+----------+---------------------+
1 row in set (4.01 sec)
```

- 하나의 Sql 에서 now() 함수는 같은 값을 가지지만, sysdate() 함수는 호출되는 시점에 따라 결괏값이 달라진다.
- sysdate() 의 두 가지 문제점
    - sysdate 가 사용된 sql 은 레플리카 서버에 안정적으로 복제되지 못한다.
    - sysdate 함수와 비교되는 컬럼은 인덱스를 효율적으로 사용하지 못한다.
        - 함수가 호출될 때마다 다른 값을 반환하므로 사실상 상수가 아니다.
        - 매번 새로운 값을 반환한다.
        - now() 함수는 sql 이 실행되고 최초 실행후 값을 할당받아 계속해서 같은 값을 사용한다.

### 11.3.3.3 날짜와 시간의 포맷(date_format, str_to_date)

- datetime 타입의 컬럼이나 값을 원하는 형태의 문자열로 변환해야 할 때는 date_format() 함수를 사용

```
mysql> select date_format(now(), '%Y-%m-%d-%H-%i-%s') as date_format;
+---------------------+
| date_format         |
+---------------------+
| 2022-04-14-22-48-50 |
+---------------------+
1 row in set (0.00 sec)
mysql>
```

### 11.3.3.6 문자열 처리(RPAD,LPAD, / RTRIM, LTRIM, TRIM)

### 11.3.3.6 문자열 결합 (concat)

```
mysql> select concat('yang', ' ' , 'youzheng' , ' ', '짱');
+-----------------------------------------------+
| concat('yang', ' ' , 'youzheng' , ' ', '짱')  |
+-----------------------------------------------+
| yang youzheng 짱                              |
+-----------------------------------------------+
1 row in set (0.00 sec)
```

### 11.3.3.8 group by 문자열 결합 (group_concat)

```
mysql> select group_concat(dept_no separator '|') from departments;
+----------------------------------------------+
| group_concat(dept_no separator '|')          |
+----------------------------------------------+
| d009|d005|d002|d003|d001|d004|d006|d008|d007 |
+----------------------------------------------+
1 row in set (0.00 sec)
```

- 응용

```
mysql> select d.dept_no, group_concat(de2.emp_no)
    -> from departments d
    ->          left join lateral ( select de.dept_no, de.emp_no
    ->                              from dept_emp de
    ->                              where de.dept_no = d.dept_no
    ->                              order by de.emp_no asc
    ->                              limit 10) de2 on de2.dept_no = d.dept_no
    -> group by d.dept_no;
+---------+-------------------------------------------------------------+
| dept_no | group_concat(de2.emp_no)                                    |
+---------+-------------------------------------------------------------+
| d001    | 10017,10055,10058,10108,10140,10175,10208,10228,10239,10259 |
| d002    | 10042,10050,10059,10080,10132,10144,10146,10147,10165,10173 |
| d003    | 10005,10013,10036,10039,10054,10071,10077,10080,10086,10100 |
| d004    | 10003,10004,10010,10018,10020,10024,10026,10029,10030,10032 |
| d005    | 10001,10006,10008,10012,10014,10018,10021,10022,10023,10025 |
| d006    | 10009,10010,10029,10033,10067,10073,10111,10124,10138,10152 |
| d007    | 10002,10016,10034,10041,10050,10053,10060,10061,10068,10087 |
| d008    | 10007,10015,10019,10040,10046,10052,10064,10070,10082,10094 |
| d009    | 10011,10038,10049,10060,10088,10098,10112,10115,10126,10128 |
+---------+-------------------------------------------------------------+
9 rows in set (0.01 sec)
```

### 11.3.3.9 값의 비교와 대체 (case when ... then ... end)

- 프로그래밍의 switch 문과 같다. 자세한 내용 생략

### 11.3.3.10 타입의 변환(cast, convert)

- Prepared Statement 를 제외하면 SQL 은 텍스트 기반으로 작동하기 때문에 Sql 에 포함된 모든 입력 값은 문자열처럼 취급
- cast, convert 함수를 사용해 형변환을 할 수 있다.
- 문자열,숫자, 날짜의 변환은 명시적으로 해주지 않아도 자동으로 변환하는 경우가 많지만
- Signed, Unsigned 같은 부화 있는 정수 또는 부호 없는 정수값의 변환은 명시적으로 타입 변환을 해야한다.

```
mysql> select cast('1234' as signed integer), cast('2020-01-01' as date);
+--------------------------------+----------------------------+
| cast('1234' as signed integer) | cast('2020-01-01' as date) |
+--------------------------------+----------------------------+
|                           1234 | 2020-01-01                 |
+--------------------------------+----------------------------+
1 row in set (0.00 sec)
```

- convert() 함수는 타입을 변환하는 용도와 문자열의 문자 집합을 변환하는 용도 두 가지가 있다.

```
mysql> select convert(1-2, unsigned), convert('abc' using 'utf8mb4');
+------------------------+--------------------------------+
| convert(1-2, unsigned) | convert('abc' using 'utf8mb4') |
+------------------------+--------------------------------+
|   18446744073709551615 | abc                            |
+------------------------+--------------------------------+
1 row in set (0.00 sec)
```

### 11.3.3.15 IP 주소 변환

- "127.0.0.1" 을 보통 varchar(15) 로 저장하지만 4바이트의 값으로 변환하여 저장하게 해준다.
- INET_ATON(), INET_NTOA()

```
mysql> select inet_aton('127.0.0.1'), inet_ntoa(2130706433);
+------------------------+-----------------------+
| inet_aton('127.0.0.1') | inet_ntoa(2130706433) |
+------------------------+-----------------------+
|             2130706433 | 127.0.0.1             |
+------------------------+-----------------------+
1 row in set (0.00 sec)
```

### 11.4 select

### 11.4.1 select 절의 처리 순서

- 일반적인 쿼리 절의 실행 순서
    1. 드라이빙 테이블, 드리븐 테이블 where 적용 및 조인 실행
    2. group by
    3. distinct
    4. having 조건 적용
    5. order by
    6. limit
- sql 에는 order by 나 group by 절이 있더라도 인덕스를 이용해 처리할 때는 그 단계 자체가 불필요하므로 생략된다.
- 쿼리 각 절의 실행 순서(예외적으로 order by 가 조인보다 먼저 실행되는 경우)
    1. 드라이빙 테이블 where 적용
    2. order by
    3. 드리븐 테이블 조인 실행
    4. limit
- 주로 group by 절 없이 order by 만 사용된 쿼리에서 사용될 수 있는 순서다.

### 11.4.2.1 인덱스를 사용하기 위한 기본 규칙

- 기본적으로 인덱스된 컬럼의 값 자체를 변환하지 않고 그대로 사용한다는 조건을 만족해야 한다.
- where 절에 사용되는 비교 조건에서 연산자 양쪽의 두 비교 대상 값은 데이터 타입이 일치해야한다.

### 11.4.2.2 where 절의 인덱스 사용

- where 조건이 인덱스를 사용하는 방법은 크게 `작업 범위 결정 조건`과 `체크 조건` 두 가지로 구분할 수 있다.

### 11.4.2.3 group by 절의 인덱스 사용

- group by 절에 명시된 컬럼의 순서가 인덱스를 구성하는 컬럼의 순서와 같으면 group by 절은 일단 인덱스를 이용할 수 있다.
- 컬럼이 하나인 단일 컬럼 인덱스도 똑같이 적용된다.
    - group by 절에 명시된 컬럼이 인덱스 컬럼의 순서와 위치가 같아야 한다.
    - 인덱스를 구성하는 컬럼 중에서 뒤쪽에 있는 컬럼은 group by 절에 명시되지 않아도 인덱스를 사용할 수 있지만 인덱스 앞쪽에    
      있는 컬럼이 group by 절에 명시되지 않으면 인덱스를 사용할 수 없다.
    - where 조건절과 달리 group by 절에 명시된 컬럼이 하나라도 인덱스에 없으면 group by 절은 전혀 인덱스를 이용하지 못한다.

### 11.4.2.4 order by 절의 인덱스 사용

- order by 의 요건과 거의 흡사하다.
- 하지만 정렬되는 각 컬럼의 오름차순 내림차순 옵션이 인덱스와 같거나 정반대인 경우에만 사용할 수 있다.

### 11.4.3.1 null 비교

- MySql 에서는 null 값이 포함된 레코드도 인덱스로 관리된다. 인덱스에서는 `null 을 하나의 값으로 인정`해서 관리한다는 것을 의미
- 두 값이 모두 null 을 가진다고 하더라도 이 두값이 동등한지 비교하는 것은 불가능하다.
- 연산이나 비교에서 한쪽이라도 null 이면 그 결과도 null 이 반환되는 이유가 바로 이것이다.
- null 인지 비교하려면 "`is null`(<=>)" 연산자를 사용해야한다.

### 11.4.3.2 문자열이나 숫자 비교

- 문자열 컬럼이나 숫자 컬럼을 비교할 때는 반드시 그 타입에 맞는 상숫값을 사용하는 것을 권장한다.
- 숫자 타입 > 문자 타입의 우선 순위를 갖고 있기 때문에 숫자와 문자 비교 연산에서는 `문자 -> 숫자로 타입 변환`하여 비교하는데   
  만약 자동 형변환되는 값이 인덱스라면 인덱스를 사용할 수 없다.

### 11.4.3.3.1 date 또는 datetime 과 문자열 비교

- date 또는 datetime 타입의 값과 문자열을 비교할 때는 문자열 값을 자동으로 datetime 타입의 값으로 변환해서 비교를 수행한다.
- date 나 datetime 타입이면 별도로 문자열을 date 나 datetime 으로 `명시적으로 변환하지 않아도 내부적으로 변환`하여 비교를 수행
- date,datetime 을 문자열로 변경하지 마고 비교하는 상수 형변환하여 비교하는 방식으로 쿼리를 작성해야한다.(index)
- 날짜를 더하고 빼는 함수를 통해 값을 변경해도 인덱스를 사용할 수 없다.

### 11.4.3.3.2 date 와 datetime 의 비교

- datetime 값에서 시간 부분만 떼어 버리고 비교하려면 `date()` 함수를 사용하자.
- datetime 과 date 타입의 비교에서 타입 변환은 `인덱스의 사용 여부에 영향을 미치지 않는다`.

```
mysql> select count(*) from employees where hire_date > date(now());
+----------+
| count(*) |
+----------+
|        0 |
+----------+
1 row in set (0.01 sec)
```

### 11.4.3.4 short-circuit evaluation

- 여러 개의 표션식이 and 또는 or 논리 연산자로 연결된 경우 선행 표현식의 결과에 따라 후행 표현식을 평가할지 말지 결정하는 최적화
- 인덱스를 사용하지 못하는 조건식이 2가지 일때, 먼저 명시된 조건식의 결과에서 두 번째 조건식을 적용하기 때문에 조건식의 순서는    
  중요하다.
- 인덱스를 사용할 수 있을 때는 where 조건절에 나열된 조건의 순서의 영향을 받지 않는다. 인덱사 사용 여부에 영향을 미치지도 않는다.