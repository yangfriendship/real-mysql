# Real Mysql Chapter5

Lock: 동시성을 제어하기 위한 기능, 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 한 시점에는 하나의 커넥션만 변경할   
수 있게 해주는 역할을 한다. Transaction: 데이터의 정합성을 보장하기 위한 기능   
격리수준: 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨을 의미

### 5.1 트랜잭션

### 5.1.1 MySql 에서의 트랜잭션

- 트랜잭션은 되로록 빨리 끝내야 한다.

### 5.2 MySql 엔진의 잠금

- MySql 에서 사용되는 잠금은 크게 스토리지 엔진 레벨과 MySql 엔진 레벨로 나뉜다.
- MySql 엔진 레벨의 잠금
    - 모든 스토리지 엔진에 영향을 미침.
- 스토리지 엔진 레벨의 잠금
    - 엔진과 상호 영향을 미치지 않음.

### 5.2.1 글로벌 락

- MySql 에서 제공하는 잠금 가운데 가장 범위가 크다.
- 한 세션에서 글로벌 락을 획득하면 다른 세선에서 SELECT 를 제외한 대부분의 DDL DML 문장을 실행하는 경우 글로벌 락이 해제될 때    
  까지 해당 문장이 대기 상태로 남는다.
- MySql 서버 전체에 영향을 미친다.

### 5.2.2 테이블 락

- 개별 테이블 단위로 설정되는 잠금
- InnoDB 데이블에도 테이블 락이 설정되지만 대부분의 데이터 변경 쿼리에서는 무시되고 스키마를 변경하는 쿼리의 경우 영향을 미친다.

### 5.2.3 네임드 락

``` SELECT GET_LOCK('mylock', 2);'```

- 2초동안 mylock 이라는 문자열에 잠금을 획득
- GET_LOCK: 잠금을 얻을 문장열과 지속 시간(초)
- IS_FREE_LOCK: 잠금이 설정돼 있는지 확인
- RELEASE_LOCK: 잠금을 반납

### 5.2.4 메타데이터락

- 데이터베이스 객체(테이블,뷰)의 이름이나 구조를 변경하는 경우에 획득하는 잠금
- 명시적으로 획득하는게 아니라, 테이블의 이름을 변경하는 경우 자동으로 획득한다.

### 5.3 InnoDB 스토리지 엔진 잠금

### 5.3.1 InnoDB 스토리지 엔진의 잠금

### 5.3.1.1 레코드락

- 레코드 자체만을 잠그는 락
- InnoDB 스토리지 엔진은 레코드 자체가 아니라 인덱스의 레코드르 잠근다.
- 인덱스가 하나도 없는 데이블이라도 내부적으로 자동 생성된 클로스터 인덱스를 이용해 잠금을 설정

### 5.3.1.2 갭락

- MySql 만의 락
- 레코드 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 락
- 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 역할을 한다.

### 5.3.1.3 넥스트 키 락

- REPEATABLE READ 격리 수준에서 사용한다.
- 갭락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 레플리카 서버에 실행될 때 소스 서버에서 만들어 낸 결과와 동일한 결과를   
  만들어내도록 보장하는 것이 주목적

### 5.3.1.4 자동증가 락

- AUTO_INCREMENT 에 적용하는 락
- INSERT, REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간 잠깐 걸리는 락
- 명시적으로 획득할 수는 없다.

### 5.3.2 인덱스와 잠금

- InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉 변경해야 할 레코드를 찾기 위해 검색한 인덱스의   
  레코드를 모두 락을 걸어야한다.
- first_name(index) = 'youzheng' 인 레코드가 30개인 경우 (last_name = 'yang')
  ``` update employees set ... where first_name ='youzheng' and last_name = 'yang'```
- 하나의 레코드만 변경하는 업데이트지만 30개의 레코드가 모두 잠금에 걸린다.
- 만약 index 가 존재하지 않는 경우에는 모든 레코드에 잠금을 걸어버린다...
- 다른 세션에서 update 문을 실행한다면 상위 작업이 끝날때까지 락이 걸린 30(1+29) 개의 레코드에는 접근할 수 없다.

### MySql 의 격리 수준

- 여러 트랜잭션이 동시에 처리될 때 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있게 허용할지 말지를 결정하는 것

|제목|DIRTH READ|NON-REPEATABLE READ|PHANTOM READ|
|----------------|---|------|------|
|READ UNCOMMITTED|O|O|O|
|READ COMMITTED|X|O|O|
|REPEATABLE READ|X|X|O(InnoDB는 없음)|
|SERIALIZABLE|X|X|X|

### Dirty Read

- 어느 트랜잭션에서 처리한 작업이 완료(commit|rollback)되지 않았는데도 다른 트랜잭션에서 볼 수 있는 현상

### NON-REPEATABLE READ

- 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 REPEATABLE 정합성에 어긋나는 것
- 사용자 A가 조회(변경전레코드) -> 사용자 B가 변경 -> 사용자 A가 조회(변경후레코드): A 사용자는 한 트랜잭션에서 2번 SELECT 실행
- 사용자 A가 실행한 쿼리의 값이 다르게 나타나게 된다.

### PHANTOM READ
- 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다 안 보였다 하는 현상
### 5.4.1 READ UNCOMMITTED

- 각 트랜잭션에서의 변경 내용이 커밋이나 롤백 여부에 상관없이 다른 트랜잭션에서 보인다.
- [DIRTY READ](#dirty-read) 가 발생

### 5.4.2 READ COMMITTED

- 온라인 서비스에서 가장 많이 선태되는 격리 수준
- 더티 리드 같은 현상은 발생하지 않는다.
- 어떤 트랜잭션에서 데이터를 변경했더라도 커밋이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있다.
- 변경 중인 레코드의 데이터를 가져오는 것이 아니라 언두 영역에 백업된 레코드의 데이터를 가져온다.
- 변경한 내용이 커밋되기 전까지는 변경내역을 조회할 수 없기 때문에 언두 영역의 백업 데이터를 이용!
- [NON-REPEATABLE READ](#non-repeatable-read) 라는 부정합의 문제가 있다.

### 5.4.3 REPEATABLE READ
- InnoDB 스토리지 엔진에서 기본으로 사용되는 격리 수준
- [NON-REPEATABLE READ](#non-repeatable-read) 라는 부정합의 문제가 발생하지 않는다.
- READ COMMITTED 와 차이는 언두 영역에 백업된 레코드의 여러 버전 가지운데 몇 번째 이전 버전까지 찾아 들어가야 하느냐에 있음
- MVCC 를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할    
  수 없다.
- 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터는 보존돼야 한다.
- 자신의 트랜잭션 번호보다 작은 트랜잭션이 남긴 언두 영역의 데이터만 본다.
- SELECT FOR UPDATE, SELECT LOCK IN SHARE MODE 를 사용한다면 [PHANTOM READ](#phantom-read) 가 발생할 수도 있다.

### 5.4.4 SERIALIZABLE
- 가장 단순하면서 가장 엄격한 격리 수준. 동시성 처리 성능도 다른 격리 수준보다 떨어진다.
- 읽기 작업도 공유 잠금을 획득해야만 하며, 동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.
- 한 트랜잭션에서 일고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다.
- [PHANTOM READ](#phantom-read) 가 발생하지 않는다.
- InnoDB 에서 갭 락과 넥스트 키락을 사용하면 REPEATABLE READ 에서도 [PHANTOM READ](#phantom-read) 가 발생하지 않기    
  때문에 SERIALIZABLE 를 사용할 필요는 없다.