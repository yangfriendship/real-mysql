# Real Mysql Chapter8

### 8.1 디스크 읽기 방식
- 데이터베이스의 성능 튜닝은 어떻게 디스크 IO 를 줄이느냐가 관건일 때가 가장 많다.

### 8.1.1 HDD, SSD
- SSD 는 기존 하드 드스크 드라이브에서 저장용 플래터를 제거하고 그 대신 플래시 메모리를 장착
- 디스크 원판을 기계적으로 회전시킬 필요가 없어서 아주 빨리 데이터를 읽고 쓸 수 있다.
- 플래시 메모리는 전원이 공급 되지 않아도 데이터가 삭제되지 않는다.
- 순차 IO 의 경우 SSD 와 HDD 의 차이가 크지 않다.
- 랜덤 IO 의 경우 SSD가 훨씬 빠르다. 랜덤 IO를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD 가 더 좋은 선택

### 8.1.2 랜덤 IO 와 순차 IO
- 랜덤 IO 라는 표현은 디스크의 플래터를 돌려서 읽어야할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것
- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 IO 를 사용하며, 풀 테이블 스캔은 순차 IO 를 사용한다.

### 8.2 인덱스란?
- 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸리기 때문에 컬럼(컬럼들)의 값과 해당 레코드가 저장된 주소를    
  키와 값의 쌍으로 삼아 인덱스를 만들어 두는것
- 현실에서의 색인과 데이터베이스의 인덱스의 가장 중요한 공통점의 `정렬` 이다
- 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.
- Primary Key
  - 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스를 의미
  - 식별할 수 있는 기준값이 되기 때문에 식별자라고 부른다.
  - NULL 값을 허용하지 않으며 중복도 허용하지 않는다.
- Secondary Index
  - Primary Key 를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류
  - 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체키라고 불린다.
- B-Tree Algorithm(Balanced)
  - 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  - 가장 많이 오랫동안 사용되어 왔다.
- Hash Index Algorithm
  - 컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색을 지원
  - 전방 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.

### 8.4 B-Tree 인덱스

### 8.3.1 구조 및 특성
- 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태
- 트리 구조의 가장 하위에 있는 노드를 리프 노드라고 한다.
- 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 브랜치 노드라고 한다.
- 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의 순서대로 저장되어 있다.
- 레코드가 삭제되어 빈 공간이 생기면 그다음의 INSERT 는 가능한 한 삭제된 공간을 재활용하도록 설계되기 때문에 항상 INSERT 된    
  순서로 저장되는 것은 아니다.(데이터 파일)
- 인덱스의 리프 노드는 데이터 파일에 `저장된 레코드의 주소`를 가진다.
- InnoDB 스토리지 엔진을 사용하는 데이블에서는 PK가 곧 ROWID의 역할을 한다.
- MyISAM 테이블은 세컨터리 인덱스가 물리적 주소를 가지는 반면 InnoDB 테이블은 PK 를 주소처럼 사용하기 때문에 논리적인 주소를    
  가진다고 볼 수 있다. -> `세컨더리 인덱스(키)의 값은 PK 인덱스` 
- 즉, 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK 를 저장하고 있는 B-Tree 를 다시 검색해야한다.

### 8.3.2.4 B-Tree 인덱스 키 검색
- B-Tree 인덱스를 이용한 검색은 `100% 일치` 또는 값의 `앞부분(Left-most part)만 일치`하는 경우에 사용할 수 있다.
- 부등호 비교 조건에서도 인덱스를 활용할 수 있지만, 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.
- 그러므로, 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree 의 장점을 이용할 수 없다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.3 선택도(기수성)
- 인덱스에서도 선택도 또는 기수성은 거의 같은 의미로 사용, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
- 인덱스 키 값 가운데 중복된 값이 많아지면 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
- 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

### 8.3.3.4 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것 보다 높은 비용이 든다.
- 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업으로 예측
- 전체 테이블 레코드의 20~25%를 넘어가면 인덱스를 사용하지 않고 모두 직접 읽어서 필터링을 거치는게 낫다.

### 8.3.4.1 인덱스 레인지 스캔
- 인덱스의 접근 방법 가운데 가장 대표적인 접근 방식(가장빠르다)
- 인덱스를 통해 루트 노드 > 브랜치 노드 > 리프 노드에 도착하여 스캔을 시작할 레코드 시작 지점을 찾을 수 있다.
- 그후로는 리프 노드의 레코드만 순서대로 읽는다.
- 인덱스 레인지 스캔 과정
  1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. (인덱스 탐색)
  2. 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽는다.(인덱스 스캔)
  3. 2번에서 읽어들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽는다.

### 8.3.4.2 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식
- 대표적으로 인덱스의 첫 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
- 인덱스의 크기는 테이블 크기보다 작으므로 직접 테이블을 읽는 것보다 인덱스만 읽는 것이 효율적이다.
- 인덱스 리프 노드의 제일 앞 또는 뒤로 이동후 리프 노드 사이를 따라서 풀 스캔하는 방식이다.

### 8.3.4.3 루스 인덱스 스캔
- 느슨하게 또는 듬성듬성하게 인덱스를 읽는 방식
- group by 잡업을 처리학 위해 인덱스를 사용하는 경우에만 적용할 수 있다.
- 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필용치 않은 인덱스 키 값은 스킵하고 다음으로 넘어가는 형태로 처리
- group by 에서 인덱스 조건에 해당하지 않는 경우 필터링하여 넘어가는 방식(where 절에 인덱스가 조건으로 사용)

### 8.3.4.4 인덱스 스킵 스캔
- 두 개의 컬럼으로 만들어진 인덱스에서 두 번째 컬럼만 where 절의 조건으로 사용한다면 인덱스를 효율적으로 사용할 수 없다.   
- 두 번째 컬럼만 사용한다면 인덱스 레인지 스캔을 사용할 수 없다.
``` select * from table t where column2 = .... ```   
- 옵티마이저는 상위 쿼리를 아래와 같이 두 가지 쿼리로 나눠 처리하도록 한다.   
``` select * from table t where gender = 'M' ... and column2 = .... ```   
``` select * from table t where gender = 'F' ... and column2 = .... ```     
- 다음과 같은 단점이 있다.
  - where 조건절에 조건이 없는 인덱스의 선행 컬럼의 유니크한 값의 개수가 적어야함. (ex.gender, y or n)
  - 쿼리가 인덱스에 존재하는 컬럼만 처리 가능해야함(커버링 인덱스)

### 8.3.5 다중 컬럼 인덱스
- 두 개 이상의 컬럼으로 구성된 인덱스를 다중 컬럼 인덱스
- 2개 이상의 컬럼이 연결됐다고 해서 `Concatenated Index` 라고도 한다.

### 8.3.6 B-Tree 인덱스의 정렬 및 스캔 방향
- 인덱스의 키 값은 항상 오름차순이거나 내림차순으로 정렬되어 저장된다.
- 인덱스가 오름차순으로 생성되었다고 오름차순으로만 사용할 수 있는 것은 아니다.
- 쿼리에 따라 옵티마이저가 실시간으로 만들어 내는 실행 계획에 따라 결정된다.

### 8.3.6.1 인덱스의 정렬
- MySql 8.0 부터는 정렬의 혼합 인덱스도 생성할 수 있다.(ex. asc/desc, desc/desc/asc)

### 8.3.6.1.1 인덱스 스캔 방향
- 인덱스 생성 시점에 오름차순 또는 내림차순으로 정렬이 결정되지만 쿼리가 그 인덱스를 사용할 시점에 인덱스를 읽는    
  방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다.
- 쿼리의 order by 처리나 min() 또는 max() 함수 등의 최적화가 필요한 경우에도 옵티마이저는 인덱스의 읽기 방향을 전환해서   
  사용하도록 실행 계획을 만들어 낸다.

### 8.3.7.2 인덱스의 가용성
- B-Tree 인덱스의 특징은 왼쪽 값에 기준(Left-most)해서 오른쪽 값이 정렬돼 있다는 것
- 하나의 컬럼 내에서 뿐만 아니라 다중 컬럼 인덱스에도 함께 적용
- 하나의 컬럼으로 검색해도 값의 왼쪽부분이 없으면 인덱스 레인지 스캔의 검색 불가능.
- 다중 컬럼 인덱스에서도 왼쪽 컬럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.

### 8.3.7.3 가용성과 효율성  판단
- B-Tree 인덱스는 다음과 같은 조건에서 작업 범위 걸정 조건으로 사용할 수 없다.
  - NOT-EQUAL 로 비교되는 경우
  - LIKE %??(뒷부분 일치) 형태로 문자열을 비교하는 경우
  - 스토어 함수나 다른 연산자로 인덱스 컬럼이 변경된 후 비교된 경우
  - NOT_DETERMINISTIC 속성의 스토어 함수가 비교 조건에 사용된 경우
  - 데이터 타입이 서로 다른 비교(인덱스 컬럼의 타입을 변환해야 비교가 가능한 경우, 데이터타입 우선순위 참고)
  - 문자열 데이터의 콜레이션이 다른 경우(콜레이션 참고)

### 8.8 클러스터링 인덱스
- 클러스터링이란 여러 개를 하나로 묶는다는 의미로 주로 사용된다.
- MySql 서버에서 클러스터링은 테이블의 레코드를 비슷한 것(PK기준)들끼리 묶어서 저장하는 형태로 구현된다.
- 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안되었다.
- InnoDB 만 지원

### 8.8.1 클러스터링 인덱스
- 테이블의 PK 에 대해서만 적용되는 내용이다.
- `PK 키 값이 비슷한 레코드끼리 묶어서 저장하는 것`을 클러스터링 인덱스라고 표현한다.
- `PK 키 값에 의해 레코드의 저장위치가 결정`된다.
- PK 값이 변경된다면 그 `레코드의 물리적인 저장 위치가 변경`되어야 한다는 것을 의미
- PK 키 값에 의해 레코드의 저장 위치가 결정되므로 사실 인덱스 알고리즘이라고 보기보다 테이블 레코드의 저장방식이라 할 수 있다.
- 클러스터링의 기준이 되는 PK 키는 `클러스터링 `키라고도 표현
- 장단점
  - 검색이 매우 빠르다.
  - 레코드의 정이나 PK 의 변경이 상대적으로 느리다.
- 클러스터링 인덱스의 리프 노드에는 레코드의 모든 컬럼이 같이 저장되어 있다.
- 그 자체가 하나의 거대한 인덱스 구조로 관리된다.
- PK 가 없는경우 InnoDB 가 다음 우선순위대로 PK 를 대체할 컬럼을 선정
  - PK 가 있으면 PK 를 클러스터링 키로 선정
  - NOT NULL 옵션의 유니크 인덱스 중에서 첫 번째 인덱스를 클러스터링 키로 지정
  - 자동으로 유니크한 값을 가지도록 증가되는 컬럼을 내부적으로 추가한 후 클러스터링 키로 선택
    - InnoDB 만 사용하고 외부에 노출하기 때문에 최소한 `AUTO_INCREMENT` 를 쓰는게 낫다.
    - PK는 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 컬럼을 PK 로 설정하는 것이 좋다.

### 8.8.2 세컨더리 인덱스에 미치는 영향
- 클러스터링 테이블의 경우 모든 세컨더리 인덱스가 PK 값을 포함한다.
- PK 의 크기가 커지면 세컨더리 인덱스도 자동으로 크기가 커진다.
- 인덱스가 커질수록 같은 성능을 내기 위해 그만큼의 메모리가 더 필요하기 때문에 PK 는 신중하게 선택해야 한다.

### 8.9 유니크 인덱스
- 사실 인덱스라고 보기 보다는 제약 조건에 가깝다고 볼 수 있다.
- MySql 에서는 인덱스 없이 유니크 제약만 설정할 수 없다. 
- MySql 에서는 유니크 컬럼에 null 값도 저장될 수 있다. 또한 null 은 특정 값이 아니기 때문에 2개 이상 저장 될 수 있다.
- InnoDB 테이블의 프라이머리 키는 클러스터링 키의 역할도 하므로 유니크 인덱스와는 근본적으로 다르다.
     
### 8.9.1 유니크 인덱스와 일반 세컨더리 인덱스의 비교
### 8.9.1.2 인덱스 쓰기
- 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는지 검사하는 과정이 더 필요하다.
- 그래서 유니크하지 않은 세컨더리 인덱스의 쓰기보다 느리다.
- 중복을 확인하는 과정에서 `읽기 잠금`을 사용, 쓰기하는 과정에서는 `쓰기 잠금` -> 데드락이 빈번하게 발생
- 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼가 사용된다.(InnoDB)
- 꼭 필요한 경우라면 유니크 인덱스를 생성하는 것이 좋지만, 불필요하게 만들지는 말자.
- 유니크 인덱스도 일반 세컨더리 인덱스와 같은 열할을 동일하게 수행하므로 세컨더리 인덱스를 중복으로 만들지도 말자.

### 8.10 외래키
- InnoDB 스토리지 엔진에서만 생성할 수 있다.
- 외래키 제약이 설정되면 `자동으로 연관되는 테이블의 컬럼에 인덱스가 생성된`다.
- 외래키가 제거 되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.
- InnoDB 의 외래키의 특성
  - 테이블의 변경(쓰기 잠금) 이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
  - 외래키와 연관되지 않은 컬럼의 변경은 최대한 잠금 경합을 발생시키지 않는다.
- 자식 테ㅔ이블의 외래 키 컬럼의 변경은 부모 테이블의 확인이 필요하다. 부모 테이블의 레코드가 쓰기 잠근이 걸려 있으면 해당 쓰기     
  잠금이 해제될 때까지 기다린다.
- 자식테이블이 생설될 때 정의된 외래키의 특성 때문에 부모 레코드가 삭제되면 자식 레코드도 동시에 삭제되는 식으로 작동하기 때문에    
  자식테이블의 레코드가 변경될 때 부모 테이블의 레코드가 변경된다면 자식 레코드의 작업이 완료될 때까지 기다린다.

### 8장 기타
그밖에도 아래와 같은 종류의 인덱스가 있다
- 가상 컬럼을 이용한 인덱스(8.6.1)
- 함수를 이용한 인덱스(8.6.2)
- 멀티 밸류 인덱스(8.7)



