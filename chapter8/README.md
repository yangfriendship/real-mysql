# Real Mysql Chapter8

### 8.1 디스크 읽기 방식
- 데이터베이스의 성능 튜닝은 어떻게 디스크 IO 를 줄이느냐가 관건일 때가 가장 많다.

### 8.1.1 HDD, SSD
- SSD 는 기존 하드 드스크 드라이브에서 저장용 플래터를 제거하고 그 대신 플래시 메모리를 장착
- 디스크 원판을 기계적으로 회전시킬 필요가 없어서 아주 빨리 데이터를 읽고 쓸 수 있다.
- 플래시 메모리는 전원이 공급 되지 않아도 데이터가 삭제되지 않는다.
- 순차 IO 의 경우 SSD 와 HDD 의 차이가 크지 않다.
- 랜덤 IO 의 경우 SSD가 훨씬 빠르다. 랜덤 IO를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSD 가 더 좋은 선택

### 8.1.2 랜덤 IO 와 순차 IO
- 랜덤 IO 라는 표현은 디스크의 플래터를 돌려서 읽어야할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것
- 인덱스 레인지 스캔은 데이터를 읽기 위해 주로 랜덤 IO 를 사용하며, 풀 테이블 스캔은 순차 IO 를 사용한다.

### 8.2 인덱스란?
- 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래걸리기 때문에 컬럼(컬럼들)의 값과 해당 레코드가 저장된 주소를    
  키와 값의 쌍으로 삼아 인덱스를 만들어 두는것
- 현실에서의 색인과 데이터베이스의 인덱스의 가장 중요한 공통점의 `정렬` 이다
- 컬럼의 값을 주어진 순서로 미리 정렬해서 보관한다.
- Primary Key
  - 레코드를 대표하는 컬럼의 값으로 만들어진 인덱스를 의미
  - 식별할 수 있는 기준값이 되기 때문에 식별자라고 부른다.
  - NULL 값을 허용하지 않으며 중복도 허용하지 않는다.
- Secondary Index
  - Primary Key 를 제외한 나머지 모든 인덱스는 세컨더리 인덱스로 분류
  - 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 프라이머리 키를 대체해서 사용할 수도 있다고 해서 대체키라고 불린다.
- B-Tree Algorithm(Balanced)
  - 인덱스는 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
  - 가장 많이 오랫동안 사용되어 왔다.
- Hash Index Algorithm
  - 컬럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘, 매우 빠른 검색을 지원
  - 전방 일치와 같이 값의 일부만 검색하거나 범위를 검색할 때는 해시 인덱스를 사용할 수 없다.

### 8.4 B-Tree 인덱스

### 8.3.1 구조 및 특성
- 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태
- 트리 구조의 가장 하위에 있는 노드를 리프 노드라고 한다.
- 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 브랜치 노드라고 한다.
- 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의 순서대로 저장되어 있다.
- 레코드가 삭제되어 빈 공간이 생기면 그다음의 INSERT 는 가능한 한 삭제된 공간을 재활용하도록 설계되기 때문에 항상 INSERT 된    
  순서로 저장되는 것은 아니다.(데이터 파일)
- 인덱스의 리프 노드는 데이터 파일에 `저장된 레코드의 주소`를 가진다.
- InnoDB 스토리지 엔진을 사용하는 데이블에서는 PK가 곧 ROWID의 역할을 한다.
- MyISAM 테이블은 세컨터리 인덱스가 물리적 주소를 가지는 반면 InnoDB 테이블은 PK 를 주소처럼 사용하기 때문에 논리적인 주소를    
  가진다고 볼 수 있다. -> `세컨더리 인덱스(키)의 값은 PK 인덱스` 
- 즉, 모든 세컨더리 인덱스 검색에서 데이터 레코드를 읽기 위해서는 반드시 PK 를 저장하고 있는 B-Tree 를 다시 검색해야한다.

### 8.3.2.4 B-Tree 인덱스 키 검색
- B-Tree 인덱스를 이용한 검색은 `100% 일치` 또는 값의 `앞부분(Left-most part)만 일치`하는 경우에 사용할 수 있다.
- 부등호 비교 조건에서도 인덱스를 활용할 수 있지만, 구성하는 키 값의 뒷부분만 검색하는 용도로는 인덱스를 사용할 수 없다.
- 그러므로, 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree 의 장점을 이용할 수 없다.

### 8.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

### 8.3.3.3 선택도(기수성)
- 인덱스에서도 선택도 또는 기수성은 거의 같은 의미로 사용, 모든 인덱스 키 값 가운데 유니크한 값의 수를 의미한다.
- 인덱스 키 값 가운데 중복된 값이 많아지면 기수성은 낮아지고 동시에 선택도 또한 떨어진다.
- 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리된다.

### 8.3.3.4 읽어야 하는 레코드의 건수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것 보다 높은 비용이 든다.
- 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업으로 예측
- 전체 테이블 레코드의 20~25%를 넘어가면 인덱스를 사용하지 않고 모두 직접 읽어서 필터링을 거치는게 낫다.
