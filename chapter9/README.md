# Real Mysql Chapter9

### 9.1.1 쿼리 실행 절차
- MySql 서버에서 쿼리가 실행되는 과정 크게 3단계로 나눌 수 있다.
  - 사용자로부터 요청된 Sql 문장을 쪼개서 MySql 서버가 이해할 수 있는 수준으로 분리한다.(Parse Tree)
    - `Sql Parse` 라는 모듈에서 처리된다.
    - MySql 서버는 Sql 문장 그 자체가 아니라 Parse Tree 를 이용해 쿼리를 실행한다.
  - Sql 파싱 정보를 확인하여 어떤 테이블로부터 읽고 어떤 인덱스를 이용해서 테이블을 읽을지 선택.(실행 계획)
    - 최적화 및 실행 계획 수립 단계
    - MySql 서버의 `옵티마이저` 에 의해서 수행
    - 다음과 같은 내용을 처리
      - 불필요한 조건 제거 및 복잡한 연산의 단순화
      - 여러 테이블의 조인이 있는 경우 어던 순서로 테이블을 읽을지 결정
      - 각 테이블에서 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
      - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
  - 2번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
    - 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어도오록 요청하고, MySql 엔진에서는 스토리지 엔진으로부터 받은 레코드를    
    조인하거나 정렬하는 작업을 수행한다.
- 첫 번째, 두 번째 단계는 거의 MySql 엔진에서 처리
- 세 번째 단계는 MySql 엔진과 스토리지 엔진이 동시에 참여해서 처리

### 9.1.2 옵티마이저의 종류
- 규칙 기반 최적화 방법(Rule-based optimizer, RBO)
  - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
  - 과거 상대적으로 느린 CPU 연산 탓에 사용되던 최적화 방법
- 비용 기반 최적화(Cost-based optimize, CBO)
  - 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출하여, 최소로 소요되는 처리 방식을    
    선택해 최종적으로 쿼리를 실행한다.

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔
풀 테이블 스캔
- 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.
- 다음과 같은 조건이 일치할 때 풀 테이블 스캔을 선택
  - `테이블의 레코드 건수가 너무 작아서` 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠를 경우
  - where 절이나 on 절에 인덱스를 이용할 수 있는 `적절한 조건이 없는 경우`
  - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 `옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우`
- 리드 어헤드: 어떤 영역의 데이터가 앞으로 필요할 것이라 예측해서 미리 디스크에서 읽어 버퍼 풀에 가져다 두는 것을 의미
- 풀 테이블 스캔이 실행되면 리드 어헤드 작업이 자동으로 시작한다.
  - 처음에는 포그라운드 스레드가 작동하지만 특정 시점부터는 백그라운드 스레드로 넘긴다.
- 단순히 count 만 하는 경우라면 레코드의 컬럼을 읽는 것보다 용량이 작은 인덱스를 선택하는 것이 읽기 횟수를 줄일 수 있기 때문에   
  경우에 따라서 풀 인덱스 스캔을 사용하기도 한다.


### 9.2.3 order by 처리(Using filesort)
- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort" 라는 별도의 처리를 이용하는 방법 두 가지가 있다.

### 9.2.3.1 소트 버퍼(Sort Buffer)
- 정렬을 수행하기 하기 위해서는 별도의 메모리 공간을 할당받아서 사용하는데 이를 소트 버퍼라고 한다.
- 소트버퍼는 세션메모리 영역에 해당한다. 클라이언트가 공유해서 사용할 수 있는 영역이 아니다.
- 정렬이 필요한 경우에만 할당
- 레코드의 크기에 따라 가변적으로 증가, 최대는 시스템 변수로 설정할 수 있따.
- 쿼리의 실행이 완료되면 그 즉시 시스템으로 반납된다.
- 정렬해야할 레코드의 크기가 버퍼 크기 보다 크다면 아래와 같이 수행한다.(멀티 머지)
  - 메로리의 소트 버퍼에서 정렬을 수행
  - 그 결과를 임시 디스크로 기록
  - 다시 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시저장
  - 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행

### 9.2.3.2 정렬 알고리즘
- 싱글 패스
  - 소트 버퍼에 정렬 `기준 컬럼을 포함하여 조회 대상이 되는 컬럼을 전부` 담아서 정렬을 수행하는 정렬 방식
  - 정렬에 필요하지 않은 컬럼까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행
  - PK 값으로 다시 한번 조회 대상 컬럼에 접근할 필요가 없지만 더 많은 소트 버퍼 메모리가 필요하다.
  - 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보임
- 투 패스
  - `정렬 대상 컬럼과 PK 값`만 소트 버퍼에 담아서 정렬을 수행
  - 정렬된 순서대로 다시 PK 로 테이블을 읽어 조회할 컬럼을 가져오는 정렬 방식
  - 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적(Sort Buffer 사이즈 때문에)
- 현재는 `싱글 패스 정렬` 방식이 주로 사용된다.

### 9.2.3.3 정렬 처리 방법
|정렬 처리 방법|실행 계획의 Extra 컬럼 내용|
|----------------|---|
|인덱스를 사용한 정렬|별도 표기 없음|
|조인에서 드라이빙 테이블만 정렬|"Using filesort" 메시지 표시|
|조인에서 조인 결과를 임시 테이블로 저장한 정렬|Using temporary; Using filesort|
   
- 인덱스를 사용할 수 있다면 별도의 filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환
- 인덱스를 사용할 수 없다면 where 조건에서 일치하는 레코드를 검색해 정렬 버퍼에 저장하여 filesort 진행
- MySql 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음과 같은 방법 중 하나를 선택
  - 조인의 `드라이빙 테이블`만 정렬한 다음 조인을 수행 -> 더 효율적!
  - `조인이 끝나고` 일치하는 레코드를 모두 가져온 후 정렬을 수행

### 9.2.3.3.1 인덱스를 이용한 정렬
- 반드시 order by 에 명시된 컬럼이 `드라이빙 테이블`에 속하고, order by 의 `순서대로 생선된 인덱스`가 있어야 한다.
- where 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 order by 는 같은 인덱스를 사용할 수 있어야 한다.
- 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.
- 여러 테이블이 조인된 경우에는 네스티드 루프 방식의 조인에서만 이 인덱스를 사용한 정렬을 이용할 수 있다.
- B-Tree 인덱스는 기본적으로 정렬 상태를 유지하기 때문에 순서대로 읽는 다면 정렬된 레코드를 얻을 수 있다.
- 조인이 네스티드 루프 방식으로 실행되기 때문에 조인 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.
- 조인 버퍼가 사용되면 순서가 흐트러질 수 있다.

### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬
- 조인이 수행되면 결과 레코드의 건수가 늘어나기 때문에 드라이빙 테이블을 먼저 정렬후 조인을 수행하는 방식이 정렬의 차선책이다.
- `드라이빙 테이블의 컬럼으로만 정렬 조건`이 실행될 때만 사용될 수 있는 정렬방식
- 드라이빙 테이블만 검색해서 정렬을 먼저 수행 -> 그 결과를 드리븐 테이블과 조인하여 결과를 반환

### 9.2.3.3.3 임시 테이블을 이용한 정렬
- order by 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블인 경우에 드리븐 테이블을 먼저 읽어야 정렬을 수행할 수     
  있기 때문에 조인이 먼저 진행되어야 한다.

### 9.2.4 group by 처리
- 쿼리가 스트리밍 된 처리를 할 수 없게 하는 처리중 하나(JDBC는 기본적으로 버퍼 방식, 통신횟수 절약)
- group by 가 사용된 조건은 인덱스를 사용할 수 없으므로 having 절을 튜닝, 인덱스를 생성하거나 다른 방법을 고민할 필요도 없다.
- group by 도 인덱스를 사용할 수 있는 방식과 사용할 수 없는 방식 두 가지로 나뉜다.
  - 루스 인덱스 스캔
  - 임시테이블 

### 9.2.4.1 인덱스 스캔을 이용한 group by
- order by 와 마찬가지로 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 group by 컬럼으로 이미 인덱스가 있다면 그    
  인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과를 조인 처리한다.

### 9.2.4.2 루스 인덱스 스캔을 이용하는 group by
- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 방식
- 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록 성능이 향상되는 반면, 루스 인덱스 스캔은 유티크한 값이 적을 수록 성능향상!
- 별도의 임시테이블이 필요하지 않는다.
- 루스 인덱스 스캔을 이용할 수 없는 쿼리 패턴
  - MIN()과 MAX() 이외의 집합 합수가 사용된 경우
  - group by 에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치 하지 않는 경우
  - select 절의 컬럼이 group by 와 일치하지 않는 경우

### 9.2.4.3 임시 테이블을 사용하는 group by
- 인덱스를 전혀 사용할 수 없는 경우에 임시 테이블을 사용해 group by 를 진행
- 필요한 경우 내부적으로 group by 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어 중복 제거와 집합 함수 연상 수행

### 9.2.4 distinct 처리