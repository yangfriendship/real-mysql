# Real Mysql Chapter9

### 9.1.1 쿼리 실행 절차

- MySql 서버에서 쿼리가 실행되는 과정 크게 3단계로 나눌 수 있다.
    - 사용자로부터 요청된 Sql 문장을 쪼개서 MySql 서버가 이해할 수 있는 수준으로 분리한다.(Parse Tree)
        - `Sql Parse` 라는 모듈에서 처리된다.
        - MySql 서버는 Sql 문장 그 자체가 아니라 Parse Tree 를 이용해 쿼리를 실행한다.
    - Sql 파싱 정보를 확인하여 어떤 테이블로부터 읽고 어떤 인덱스를 이용해서 테이블을 읽을지 선택.(실행 계획)
        - 최적화 및 실행 계획 수립 단계
        - MySql 서버의 `옵티마이저` 에 의해서 수행
        - 다음과 같은 내용을 처리
            - 불필요한 조건 제거 및 복잡한 연산의 단순화
            - 여러 테이블의 조인이 있는 경우 어던 순서로 테이블을 읽을지 결정
            - 각 테이블에서 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
            - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
    - 2번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.
        - 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어도오록 요청하고, MySql 엔진에서는 스토리지 엔진으로부터 받은 레코드를    
          조인하거나 정렬하는 작업을 수행한다.
- 첫 번째, 두 번째 단계는 거의 MySql 엔진에서 처리
- 세 번째 단계는 MySql 엔진과 스토리지 엔진이 동시에 참여해서 처리

### 9.1.2 옵티마이저의 종류

- 규칙 기반 최적화 방법(Rule-based optimizer, RBO)
    - 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식
    - 과거 상대적으로 느린 CPU 연산 탓에 사용되던 최적화 방법
- 비용 기반 최적화(Cost-based optimize, CBO)
    - 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출하여, 최소로 소요되는 처리 방식을    
      선택해 최종적으로 쿼리를 실행한다.

### 9.2.1 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔

- 인덱스를 사용하지 않고 테이블의 데이터를 처음부터 끝까지 읽어서 요청된 작업을 처리하는 작업을 의미한다.
- 다음과 같은 조건이 일치할 때 풀 테이블 스캔을 선택
    - `테이블의 레코드 건수가 너무 작아서` 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠를 경우
    - where 절이나 on 절에 인덱스를 이용할 수 있는 `적절한 조건이 없는 경우`
    - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 `옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우`
- 리드 어헤드: 어떤 영역의 데이터가 앞으로 필요할 것이라 예측해서 미리 디스크에서 읽어 버퍼 풀에 가져다 두는 것을 의미
- 풀 테이블 스캔이 실행되면 리드 어헤드 작업이 자동으로 시작한다.
    - 처음에는 포그라운드 스레드가 작동하지만 특정 시점부터는 백그라운드 스레드로 넘긴다.
- 단순히 count 만 하는 경우라면 레코드의 컬럼을 읽는 것보다 용량이 작은 인덱스를 선택하는 것이 읽기 횟수를 줄일 수 있기 때문에   
  경우에 따라서 풀 인덱스 스캔을 사용하기도 한다.

### 9.2.3 order by 처리(Using filesort)

- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 "Filesort" 라는 별도의 처리를 이용하는 방법 두 가지가 있다.

### 9.2.3.1 소트 버퍼(Sort Buffer)

- 정렬을 수행하기 하기 위해서는 별도의 메모리 공간을 할당받아서 사용하는데 이를 소트 버퍼라고 한다.
- 소트버퍼는 세션메모리 영역에 해당한다. 클라이언트가 공유해서 사용할 수 있는 영역이 아니다.
- 정렬이 필요한 경우에만 할당
- 레코드의 크기에 따라 가변적으로 증가, 최대는 시스템 변수로 설정할 수 있따.
- 쿼리의 실행이 완료되면 그 즉시 시스템으로 반납된다.
- 정렬해야할 레코드의 크기가 버퍼 크기 보다 크다면 아래와 같이 수행한다.(멀티 머지)
    - 메로리의 소트 버퍼에서 정렬을 수행
    - 그 결과를 임시 디스크로 기록
    - 다시 레코드를 가져와서 다시 정렬해서 반복적으로 디스크에 임시저장
    - 이처럼 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행

### 9.2.3.2 정렬 알고리즘

- 싱글 패스
    - 소트 버퍼에 정렬 `기준 컬럼을 포함하여 조회 대상이 되는 컬럼을 전부` 담아서 정렬을 수행하는 정렬 방식
    - 정렬에 필요하지 않은 컬럼까지 전부 읽어서 소트 버퍼에 담고 정렬을 수행
    - PK 값으로 다시 한번 조회 대상 컬럼에 접근할 필요가 없지만 더 많은 소트 버퍼 메모리가 필요하다.
    - 정렬 대상 레코드의 크기나 건수가 작은 경우 빠른 성능을 보임
- 투 패스
    - `정렬 대상 컬럼과 PK 값`만 소트 버퍼에 담아서 정렬을 수행
    - 정렬된 순서대로 다시 PK 로 테이블을 읽어 조회할 컬럼을 가져오는 정렬 방식
    - 정렬 대상 레코드의 크기나 건수가 상당히 많은 경우 효율적(Sort Buffer 사이즈 때문에)
- 현재는 `싱글 패스 정렬` 방식이 주로 사용된다.

### 9.2.3.3 정렬 처리 방법

|정렬 처리 방법|실행 계획의 Extra 컬럼 내용|
|----------------|---|
|인덱스를 사용한 정렬|별도 표기 없음|
|조인에서 드라이빙 테이블만 정렬|"Using filesort" 메시지 표시|
|조인에서 조인 결과를 임시 테이블로 저장한 정렬|Using temporary; Using filesort|

- 인덱스를 사용할 수 있다면 별도의 filesort 과정 없이 인덱스를 순서대로 읽어서 결과를 반환
- 인덱스를 사용할 수 없다면 where 조건에서 일치하는 레코드를 검색해 정렬 버퍼에 저장하여 filesort 진행
- MySql 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음과 같은 방법 중 하나를 선택
    - 조인의 `드라이빙 테이블`만 정렬한 다음 조인을 수행 -> 더 효율적!
    - `조인이 끝나고` 일치하는 레코드를 모두 가져온 후 정렬을 수행

### 9.2.3.3.1 인덱스를 이용한 정렬

- 반드시 order by 에 명시된 컬럼이 `드라이빙 테이블`에 속하고, order by 의 `순서대로 생선된 인덱스`가 있어야 한다.
- where 절에 첫 번째로 읽는 테이블의 컬럼에 대한 조건이 있다면 그 조건과 order by 는 같은 인덱스를 사용할 수 있어야 한다.
- 해시 인덱스나 전문 검색 인덱스 등에서는 인덱스를 이용한 정렬을 사용할 수 없다.
- 여러 테이블이 조인된 경우에는 네스티드 루프 방식의 조인에서만 이 인덱스를 사용한 정렬을 이용할 수 있다.
- B-Tree 인덱스는 기본적으로 정렬 상태를 유지하기 때문에 순서대로 읽는 다면 정렬된 레코드를 얻을 수 있다.
- 조인이 네스티드 루프 방식으로 실행되기 때문에 조인 때문에 드라이빙 테이블의 인덱스 읽기 순서가 흐트러지지 않는다.
- 조인 버퍼가 사용되면 순서가 흐트러질 수 있다.

### 9.2.3.3.2 조인의 드라이빙 테이블만 정렬

- 조인이 수행되면 결과 레코드의 건수가 늘어나기 때문에 드라이빙 테이블을 먼저 정렬후 조인을 수행하는 방식이 정렬의 차선책이다.
- `드라이빙 테이블의 컬럼으로만 정렬 조건`이 실행될 때만 사용될 수 있는 정렬방식
- 드라이빙 테이블만 검색해서 정렬을 먼저 수행 -> 그 결과를 드리븐 테이블과 조인하여 결과를 반환

### 9.2.3.3.3 임시 테이블을 이용한 정렬

- order by 절의 정렬 기준 컬럼이 드라이빙 테이블이 아니라 드리븐 테이블인 경우에 드리븐 테이블을 먼저 읽어야 정렬을 수행할 수     
  있기 때문에 조인이 먼저 진행되어야 한다.

### 9.2.4 group by 처리

- 쿼리가 스트리밍 된 처리를 할 수 없게 하는 처리중 하나(JDBC는 기본적으로 버퍼 방식, 통신횟수 절약)
- group by 가 사용된 조건은 인덱스를 사용할 수 없으므로 having 절을 튜닝, 인덱스를 생성하거나 다른 방법을 고민할 필요도 없다.
- group by 도 인덱스를 사용할 수 있는 방식과 사용할 수 없는 방식 두 가지로 나뉜다.
    - 루스 인덱스 스캔
        - 임시테이블 ftyuihjk

### 9.2.4.1 인덱스 스캔을 이용한 group by

- order by 와 마찬가지로 조인의 드라이빙 테이블에 속한 컬럼만 이용해 그루핑할 때 group by 컬럼으로 이미 인덱스가 있다면 그    
  인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과를 조인 처리한다.

### 9.2.4.2 루스 인덱스 스캔을 이용하는 group by

- 인덱스의 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 방식
- 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록 성능이 향상되는 반면, 루스 인덱스 스캔은 유티크한 값이 적을 수록 성능향상!
- 별도의 임시테이블이 필요하지 않는다.
- 루스 인덱스 스캔을 이용할 수 없는 쿼리 패턴
    - MIN()과 MAX() 이외의 집합 합수가 사용된 경우
    - group by 에 사용된 컬럼이 인덱스 구성 컬럼의 왼쪽부터 일치 하지 않는 경우
    - select 절의 컬럼이 group by 와 일치하지 않는 경우

### 9.2.4.3 임시 테이블을 사용하는 group by

- 인덱스를 전혀 사용할 수 없는 경우에 임시 테이블을 사용해 group by 를 진행
- 필요한 경우 내부적으로 group by 절의 컬럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어 중복 제거와 집합 함수 연상 수행

### 9.2.4 distinct 처리

- distinct 의 두 가지 처리 방식
    - MIN, MAX 또는 COUNT 같은 집합 함수와 함께 사용되는 경우
    - 집합 함수가 없는 경우

### 9.2.5.1 SELECT DISTINCT...

- distinct 는 특정 컬럼만 유니크하게 하는 것이 아니라 레코드 자체의 중복을 검사한다.

### 9.2.5.2 집합 함수와 함께 사용된 distinct

- 집합 함수가 없는 select 쿼리에서 distinct 는 조회하는 `모든 컬럼의 조합`이 유니크한 것들만 가져온다.
- 집합 함수 내에서 사용된 distinct 는 그 집합 함수의 인자로 전달된 컬럼의 값이 유니크한 것들만 가져온다.
- distinct 처리를 위해 인덱스를 이용할 수 없는 경우에는 임시 테이블을 생성한다.
- 인덱스된 컬럼에 대해 distinct 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하며 임시테이블을 생성하지 않는다.

### 9.3.1.1 MRR 과 배치 키 인덱스

- MRR: Multi-Range Read
- 기존의 MySql 서버의 조인은 드라이블 테이블의 레코드를 한건 읽어서 드리븐 테이블의 일치하는 레코드를 찾아서 조인을 수행하는 방식
- 이러한 방식을 네스티드 루프 조인(Nested loop Join) 이라고 한다.
    - 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우에 사용되는 조인 방식
- MRR 방식의 조인은 드라이빙 테이블의 레코드를 읽어서 드리븐 테이블과의 조인을 즉시 실행하지 않고 조인된 대상을 버퍼링하는 것
- 조인 버퍼에 레코드가 가득 차면 비로소 엔진은 버펄이된 레코드를 스토리지 엔진으로 한 번에 요청한다.
- MRR을 응용해서 실행되는 조인 방식을 BKA(Batched Key Access) 조인이라고 한다.
- BKA 조인을 사용하게 되면 부가적인 정렬 작업이 필요해지면서 오히려 성능에 안 좋은 영향을 미치는 경우도 있다.

### 9.3.1.2 블록 네스티드 루프 조인 (Block nested loop)

- 조인의 연결 조건이 되는 컬럼에 모두 인덱스가 있는 경우에 사용되는 조인 방식
- 레코드를 읽어서 다른 버퍼 공간에 저장하지 않고 즉지 드리븐 테이블의 레코드를 찾아서 반환
- 네스티드 루프 조인과 블록 네스티드 루프 조인의 가장 큰 차이는 조인버퍼가 사용되는지 여부와 조인에서 드라이븡 테이블과 드리븐 테이블    
  이 어떤 순서에 조인되느냐다.
- 조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리 된다.
- 즉 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리된다.
- 어떤 방식으로도 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 피할 수 없다면 옵티아미저는 드라이빙 테이블에서 읽은 레코드    
  를 메모리에 캐시한 후 드리븐 테이블과 이 메로리 캐시를 조인하는 형태로 처리한다. 이때 사용되는 메모리의 캐시를 조인 버퍼라고 한다.
- 드라이빙 테이블의 결과는 조인 버퍼에 담아두고, 드리븐 테이블을 먼저 읽고 조인 버퍼에서 일치하는 레코드를 찾는 방식으로 처리된다.
- 일반적으로 조인이 수행된 후 가져오는 결과는 드라이빙 테이블의 순서에 결정되지만, 조인 버퍼가 사용되는 조인에서는 결과의 정렬순서가    
  흐트러질 수 있음을 기억해야한다.

### 9.3.1.9 세미 조인
- 다른 테이블과 실제 조인을 수행하지 않고, 단지 다른 테이블에서 조건에 일치하는 레코드가 있는지 없는지만 체크하는 형태의 쿼리

### 9.3.1.19 해시 조인
- 네스티드 루프 조인보다 해시 조인이 빠르다고 생각하지만 이는 항상 옳은 것은 아니다.
  - 해시 조인은 첫 번째 레코드를 찾는 데는 시간이 많이 걸리지만 최종 레코드를 찾는 데까지는 시간이 많이 걸리지 않는다.
  - 네스티드 루프 조인은 마지막 레코드를 찾는 데까지는 시간이 많이 걸리지만 첫 번째 레코드를 찾는 것은 상대적으로 빠르다.
  - 즉, 해시조인 쿼리는 최고 스루풋 전략에 적합하며, 네스티드 루프 조인은 최고 응답속도 전략에 적합하다.
